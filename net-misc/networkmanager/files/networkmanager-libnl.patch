--- src/NetworkManagerSystem.c.orig	2008-02-01 01:03:09.000000000 +0000
+++ src/NetworkManagerSystem.c	2008-02-01 01:12:08.000000000 +0000
@@ -234,16 +234,32 @@
 
 static struct nl_handle * new_nl_handle (void)
 {
-	struct nl_handle *	nlh = NULL;
+	struct nl_handle * nlh = NULL;
+	struct nl_cb *cb;
+	cb = nl_cb_alloc (NL_CB_VERBOSE);
+	nlh = nl_handle_alloc_cb (cb);
 
-	nlh = nl_handle_alloc_nondefault(NL_CB_VERBOSE);
-	nl_handle_set_pid (nlh, (pthread_self() << 16 | getpid()));
-	if (nl_connect(nlh, NETLINK_ROUTE) < 0)
-	{
-		nm_warning ("%s: couldn't connecto to netlink: %s", __func__, nl_geterror());
+	if (!nlh) {
+		nm_warning ("couldn't allocate netlink handle.");
+		return NULL;
+	}
+
+	if (nl_connect (nlh, NETLINK_ROUTE) < 0) {
+		/* HACK: try one more time. Because the netlink monitor for link state
+		* inits before we get here, it grabs the port that matches the PID
+		* of the NM process, which also happens to be the PID that libnl uses
+		* the first time too.  The real fix is to convert nm-netlink-monitor.c
+		* over to use libnl.
+		*/
 		nl_handle_destroy (nlh);
 		nlh = NULL;
-	}
+
+		nlh = new_nl_handle ();
+		if (!nlh) {
+		nm_error ("couldn't connect to netlink: %s", nl_geterror ());
+		return NULL;
+		}
+       }
 
 	return nlh;
 }
